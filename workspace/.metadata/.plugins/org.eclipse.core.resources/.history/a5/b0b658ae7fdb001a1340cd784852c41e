/*
 * CREATED ON:    Apr 14, 2006 4:02:41 PM
 * CREATED BY:    Amit Bansil 
 */
package cps.water;

import cps.jarch.data.event.tools.Link;
import cps.jarch.gui.util.EDTWorker;
import cps.jarch.util.misc.Worker;
import cps.water.AppModel.Model;
import cps.water.moleculedisplay.DisplayPanel;
import cps.water.simulation.ShakeFailException;
import cps.water.simulation.SimModel;
import cps.water.time.TimeModel;

import javax.swing.SwingUtilities;

import java.lang.reflect.InvocationTargetException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * <p>Main class for starting Water application. Methods should be invoked on EDT only.
 * </p>
 * @version $Id$
 * @author Amit Bansil
 */
public class Application {
	private final AppModel model;
	public final AppModel getModel() {
		return model;
	}
	private final GUI gui;
	//create application
	public Application() {
		EDTWorker.checkThread();
		simWorker=new Worker("SimulationWorker");
		
		simWorker.setDaemon(true);
		simWorker.setPriority(Thread.NORM_PRIORITY);
		simWorker.start();
		
		model=new AppModel(simWorker);
		gui=new GUI(this);
		
		Link runningL=new Link() {
			@Override public void signal() {
				boolean pr=model.getTimeModel().getRunning(true).get();
				boolean sr=model.getTimeModel().getRunning(false).get();
				if (primaryRunning!=pr
						|| secondaryRunning!=sr) {
					
					modelLock.lock();
					primaryRunning=pr;
					secondaryRunning=sr;
					modelLock.unlock();
					
					if(primaryRunning||secondaryRunning) postRender();
				}
			}
		};
		final Link displayChangeL=new Link() {
			@Override protected void signal() {
				EDTWorker.checkThread();
				postRender();
			}
		};
		Link simChangeL=new Link() {
			@Override protected void signal() {
				if(model.primarySelection().get()!=primary||model.secondarySelection().get()!=secondary) {
					if(primary!=null) primary.getDisplay().getSource().disconnect(displayChangeL);
					if(secondary!=null) secondary.getDisplay().getSource().disconnect(displayChangeL);
					
					
					modelLock.lock();
					try {
						primary=model.primarySelection().get();
						secondary=model.secondarySelection().get();
					}finally {
						modelLock.unlock();
					}
					
					primary.getDisplay().getSource().connect(displayChangeL);
					secondary.getDisplay().getSource().connect(displayChangeL);
					
					postStep();
				}
			}
		};
		model.getTimeModel().getRunning(true).connect(runningL);
		model.getTimeModel().getRunning(false).connect(runningL);
		model.getSource().connect(simChangeL);
		simChangeL.signal(null);
	}
	//make gui visible
	public final void show() {
		EDTWorker.checkThread();
		gui.show();
	}
	public final void shutdown() {
		//do nothing
	}
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		//run on EDT
		try {
			SwingUtilities.invokeAndWait(new Runnable() {
				public void run() {
					//TODO: show splashscreen,parse input files/parameters
					new Application().show();
				}
			});
		} catch (InterruptedException e) {
			//should not happen
			throw new Error(e);
		} catch (InvocationTargetException e) {
			//should not happen
			throw new Error(e);
		}
	}

	private final Lock modelLock=new ReentrantLock();
	private final Worker simWorker;
	private AppModel.Model primary,secondary;
	private boolean primaryRunning,secondaryRunning;
	private static float updateSimDelayMillis=50f;
	
	private void postStep() {
		
	}
	private void postRender() {
	}
	private void updateSims() {
		//grab models& running info
		modelLock.lock();
		AppModel.Model primary=this.primary;
		AppModel.Model secondary=this.secondary;
		boolean primaryRunning=this.primaryRunning,secondaryRunning=this.secondaryRunning;
		modelLock.unlock();
		
		//if we're running simulate nec. frames
		//direct read here is fine....
		int stepsPerSecond=Math.round(model.getTimeModel().getStepsPerSecond().get()*TimeModel.STEP_SCALE);
		int stepCount=Math.round(stepsPerSecond*(updateSimDelayMillis/1000f));
		try {
			if(primary!=null&&primaryRunning)primary.getSimModel().step(stepCount);	
			if(secondary!=null&&secondaryRunning)secondary.getSimModel().step(stepCount);	
		}catch(ShakeFailException e) {
			//TODO prompt for reset
			e.printStackTrace();
		}
		
		//wait for old renderings to finish
		//push new data to renderers
		
		//if we're running post a new update
	}
	private void updateRenderings() {
		DisplayPanel primaryDisplay=gui.primaryDisplay;
		DisplayPanel secondaryDisplay=gui.secondaryDisplay;
		modelLock.lock();
		AppModel.Model primary=this.primary;
		AppModel.Model secondary=this.secondary;
		modelLock.unlock();
		
		//read display & sim data
		if(primary!=null) {
			primaryDisplay.readDisplayModel(primary.getDisplay());
			primaryDisplay.readScene(primary.getRenderScene());
		}
		if(secondary!=null) {
			secondaryDisplay.readDisplayModel(primary.getDisplay());
			secondaryDisplay.readScene(primary.getRenderScene());
		}
		//do rendering
		//swap buffers
	}
}
