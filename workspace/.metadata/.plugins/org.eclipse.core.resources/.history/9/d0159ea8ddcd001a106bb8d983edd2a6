/*
 * CREATED ON:    Apr 16, 2006 10:41:52 PM
 * CREATED BY:    Amit Bansil 
 */
package cps.jarch.data.collections;

import ca.odell.glazedlists.EventList;
import ca.odell.glazedlists.event.ListEvent;
import ca.odell.glazedlists.event.ListEventListener;

import java.util.EventObject;
import java.util.concurrent.locks.ReadWriteLock;

import cps.jarch.data.event.Link;
import cps.jarch.data.event.Unlinker;
import cps.jarch.data.value.CheckedValue;
import cps.jarch.data.value.RejectedValueException;
import cps.jarch.data.value.ValueChange;
import cps.jarch.data.value.ValueLink;
import cps.jarch.data.value.tools.CheckedValueImp;

/**
 * <p>
 * A {@link CheckedValue} that can be used to select an item from a dynamic
 * list. Always nullable since if the is emptied the selection must be
 * <code>null</code>. If the selected item is removed from the list the
 * previous item in the list is selected.
 * </p>
 * 
 * @version $Id$
 * @author Amit Bansil
 */
public class ListItem<T> extends CheckedValueImp<T> implements Unlinker{
	/**
	 * Determines what happens if the selected item is removed from the list. If
	 * SELECT_NEXT is desired the next item will be selected unless there is no
	 * next item in which case the previous item will be selected. If
	 * SELECT_PREVIOUS is desired the previous item will be selected unless
	 * there is no previous item in which case the next item will be selected.
	 * If the list is emptied or SELECT_NONE is desired the selection will
	 * become <code>null</code>.
	 */
	public static enum OnRemove{SELECT_NEXT,SELECT_PREVIOUS,SELECT_NULL};
	
	private final EventList<T> list;
	private final ListEventListener<T> listListener;
	
	//index of cur in list or -1 if cur==null
	private int curIndex=-1;
	
	public ListItem(EventList<T> l, T initial,OnRemove onRemove) {
		this(l,initial,onRemove,null);
	}
	public ListItem(EventList<T> l, T initial,final OnRemove onRemove, ReadWriteLock lock) {
		super(true, lock);
		this.list=l;
		
		//update curIndex on value changes
		connect(new ValueLink<T>() {
			public void receive(ValueChange<T> event) {
				assert event.getNewValue() == get() :
					"current value is same as event reports";
				
				assert (event.getOldValue() == null && curIndex==-1)
						|| list.indexOf(event.getOldValue()) == curIndex :
							"curIndex points to old value";
				
				if (event.getNewValue() == null) curIndex = -1;
				else curIndex = list.indexOf(event.getNewValue());
			}
		});
		
		makeCurrentInitial();
		
		//curIndex should be set now
		assert (get() == null && curIndex==-1)
		|| list.get(curIndex) == get() :
			"curIndex points to currentValue";
		
		//do onRemove if item is removed
		listListener=new ListEventListener<T>() {
			public void listChanged(ListEvent<T> listChanges) {
				
				T cur=get();
				
				//do nothing if no selection
				if(cur==null)return;
				
				int newCurIndex=list.indexOf(cur);
				
				//read through changes
				while (listChanges.next()) {
					int type=listChanges.getType();
					int index=listChanges.getIndex();
					switch(type) {
						case ListEvent.DELETE:
							break;
						case ListEvent.INSERT:
							break;
						case ListEvent.UPDATE:
							break;
					}
				}
			}
		};
	}

	public ListItem(EventList<T> list, T initial) {
		this(list,initial,null);
	}
	public ListItem(EventList<T> list) {
		this(list,null,null);
	}

	@Override protected void check(T newValue) throws RejectedValueException {
	}

	public void unlink() {
		list.removeListEventListener(listListener);
	}
}
