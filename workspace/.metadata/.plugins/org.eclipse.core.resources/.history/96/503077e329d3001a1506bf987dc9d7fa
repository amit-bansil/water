/*
 * CREATED ON:    Apr 14, 2006 4:08:41 PM
 * CREATED BY:    Amit Bansil 
 */
package cps.water.simulation;

import cps.jarch.data.event.tools.SimpleSource;
import cps.jarch.data.event.tools.SimpleSourceImp;
import cps.jarch.data.value.RWValue;
import cps.jarch.data.value.tools.BoundedValue;
import cps.jarch.data.value.tools.RWFlag;
import cps.jarch.data.value.tools.RWValueImp;
import cps.jarch.util.collections.ArrayFinal;
import cps.jarch.util.collections.CursorableLinkedList;
import cps.jarch.util.misc.Worker;
import cps.jarch.util.notes.Nullable;
import cps.water.util.Tuple3f;

import java.util.Iterator;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

//threading:
//RWValue/BoundedValues modifiable on any thread
//step/clear/load/save/insertIon/removeIon return immediatly but execute on SimModel worker thread
//all getXXX methods (except getChangeSource) are accessible only from SimModel worker thread
//listeners to change source are notified on simModel worker thread
/**
 * <p>TODO document SimModel
 * </p>
 * @version $Id$
 * @author Amit Bansil
 */
public class SimModel {
	private final Engine raw=new Engine();
	private final ReentrantReadWriteLock lock=new ReentrantReadWriteLock();
	
	private static final Worker worker=new Worker();
	
	// ------------------------------------------------------------------------

	private int frameNumber;
	public final int getFrameNumber() {
		return frameNumber;
	}

	private final Scene scene=new Scene(raw);

	private final InputParameters inputParameters=new InputParameters(lock);

	private final OutputParameters outputParameters=new OutputParameters(lock);
	
	private final RWFlag running=new RWFlag(false);//not locked since it's never read

	
	// ------------------------------------------------------------------------
	//time
	private final BoundedValue<Integer> stepSize=new BoundedValue<Integer>(5,1,100,lock);
	public final BoundedValue<Integer> stepSize(){
		return stepSize;
	}
	
	// ------------------------------------------------------------------------

	public SimModel(SimConfig initialConfig) {
		this.initialConfig = initialConfig;
		//ok since we're not live yet
		_clear();
	}

	private SimConfig initialConfig;

	public static abstract interface ShakeFailHook{
		public void shakeFailed(ShakeFailException e);
	}
	public void step(final ShakeFailHook failHook) {
		worker.runASAP(new Runnable() {
			public void run() {
				try {
					_step();
				} catch (ShakeFailException e) {
					failHook.shakeFailed(e);
				}
			}
		});
	}
	private final void _step() throws ShakeFailException {
		
		final int steps, recordStep, recordCount;
		lock.readLock().lock();
		try {
			steps = stepSize.get();
			outputParameters.preStep();
			inputParameters.apply(raw);
		} finally {
			lock.readLock().unlock();
		}
		for (int i = 0; i < steps; i++) {
			raw.step();
			frameNumber++;
			inputParameters.step();
		}
		for (int excessRecordings = recordCount - getRecordingCount(); excessRecordings > 0;
			excessRecordings--) {
			
			recordings.removeFirst();
		}
		source.sendEvent();
	}
	
	private final void _clear() {
		nextRecord=frameNumber=0;
		raw.clear();
		scene.removeIons();
		initialConfig.toData(raw);
		raw.initial();
		raw.tempav = raw.atemp;
		raw.presav = raw.apres;
		raw.rho = raw.arho;
		raw.hbonds = 0;
		// ObjLib.boundsSize = getBoundsSize();
		//if (initialConfig != null) initialConfig.toData(raw);
		lock.writeLock().lock();
		try {
			//clearParameters
			inputParameters.clear(raw);
			
			//clear data
			recordings.clear();
			maxRecordingCount.getData().loadInitial();
			stepSize.getData().loadInitial();
			recordStepSize.getData().loadInitial();
		}finally {
			lock.writeLock().unlock();
		}
		source.sendEvent();
	}
	
	// ------------------------------------------------------------------------
	private final SimpleSourceImp source=new SimpleSourceImp(this);
	public final SimpleSource getChangeSource() {
		return source;
	}
}
